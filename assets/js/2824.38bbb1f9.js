"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[2824],{62824:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>h,frontMatter:()=>r,toc:()=>o});var a=n(87462),i=(n(67294),n(3905));const r={},s=void 0,o=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],l={toc:o},p="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Let's start by importing our requisite libraries and wire up some setup and teardown methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// filename: test/screenshot.spec.js\nconst assert = require("assert");\nconst { Builder, By } = require("selenium-webdriver");\nconst fs = require("fs");\nconst path = require("path");\n\ndescribe("Screenshot", function() {\n  let driver;\n\n  beforeEach(async function() { this.timeout(60000) driver = await new Builder().forBrowser("chrome").build();\n  });\n\n  afterEach(async function() {\n    if (this.currentTest.state !== "passed") {\n      const testName = this.currentTest.fullTitle().replace(/\\s/g, "-");\n      const fileName = path.join(__dirname, `screenshot_${testName}.jpg`);\n      fs.writeFileSync(fileName, await driver.takeScreenshot(), "base64");\n    }\n    await driver.quit();\n  });\n// ...\n')),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"afterEach")," we check to see if the test was unsuccessful (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},'this.currenTest.state !== "passed"'),"). If not, then the test has either failed or errored and we capture a screenshot through the help of Selenium's ",(0,i.kt)("inlineCode",{parentName:"p"},".takeScreenshot()")," function. To save it to disk, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"fs")," and its ",(0,i.kt)("inlineCode",{parentName:"p"},"writeFileSync")," function. It takes the full path to save to, the payload (e.g., the screenshot), and the encoding (which for the image is ",(0,i.kt)("inlineCode",{parentName:"p"},'"base64"'),")."),(0,i.kt)("p",null,"To make the filename unique we use the test name after cleaning it up (by replacing spaces with ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),"). When this command executes it will save an image file (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"screenshot_Screenshot-on-failure.jpg"),") to the local system in the current working directory."),(0,i.kt)("p",null,"Now to wire up a test which will fail."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// filename: test/screenshot.spec.js\n// ...\n  it("on failure", async function() {\n    await driver.get("http://the-internet.herokuapp.com");\n    assert(true === false);\n  });\n});\n')),(0,i.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,i.kt)("p",null,"When we save this file and run it (",(0,i.kt)("inlineCode",{parentName:"p"},"mocha")," from the command-line) here is what will happen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Open the browser"),(0,i.kt)("li",{parentName:"ul"},"Load the homepage of ",(0,i.kt)("a",{parentName:"li",href:"http://github.com/tourdedave/the-internet"},"the-internet")),(0,i.kt)("li",{parentName:"ul"},"Fail on the assertion"),(0,i.kt)("li",{parentName:"ul"},"Capture a screenshot in the current working directory"),(0,i.kt)("li",{parentName:"ul"},"Close the browser")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Having a screenshot to aid in troubleshooting failing tests along with a stack trace helps in having more insight."),(0,i.kt)("p",null,"Happy Testing!"))}h.isMDXComponent=!0}}]);