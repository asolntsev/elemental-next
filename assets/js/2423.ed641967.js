"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[2423],{62423:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>s,frontMatter:()=>i,toc:()=>o});var r=n(87462),a=(n(67294),n(3905));const i={},l=void 0,o=[{value:"A Solution",id:"a-solution",level:2},{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],p={toc:o},d="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"a-solution"},"A Solution"),(0,a.kt)("p",null,"Instead of hard-coding logging requests all over the place, we can leverage an event listener to give us the information we want -- automatically and for each Selenium action."),(0,a.kt)("p",null,"This functionality is built in to Selenium in what's called the ",(0,a.kt)("a",{parentName:"p",href:"https://code.google.com/p/selenium/source/browse/rb/lib/selenium/webdriver/support/abstract_event_listener.rb"},"AbstractEventListener"),". This is a class which comes preloaded with helper methods that enable us to add behavior before and after common Selenium actions -- here's a list of the available methods:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_navigate_to")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_navigate_to")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_navigate_back")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_navigate_back")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_navigate_forward")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_navigate_forward")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_find")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_find")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_click")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_click")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_change_value_of")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_change_value_of")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_execute_script")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_execute_script")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_quit")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_quit")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"before_close")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"after_close"))),(0,a.kt)("p",null,"We can pick and choose from each of these methods and specify the additional behavior we want to occur. After that, it's just a simple matter of passing this information to Selenium when creating a browser instance."),(0,a.kt)("p",null,"Here is an example."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"To start, let's create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Wrapper")," class that inherits from ",(0,a.kt)("inlineCode",{parentName:"p"},"AbstractEventListener")," and add our behavior there."),(0,a.kt)("p",null,"The helper methods we're interested in are ",(0,a.kt)("inlineCode",{parentName:"p"},"after_navigate_to"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"before_find"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"after_find"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"before_click"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"after_click")," and they each require different arguments to be specified. See ",(0,a.kt)("a",{parentName:"p",href:"https://code.google.com/p/selenium/source/browse/rb/lib/selenium/webdriver/support/abstract_event_listener.rb#30"},"here")," for details."),(0,a.kt)("p",null,"And to make things interesting, let's wire up jQuery Growl notifications."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},'# filename: wrapper.rb\n\nclass Wrapper < Selenium::WebDriver::Support::AbstractEventListener\n\n  def after_navigate_to(url, driver)\n    add_growl(driver)\n    display_growl(driver, "Navigated to #{url}")\n  end\n\n  def before_find(by, what, driver)\n    display_growl(driver, "Finding element #{what}")\n  end\n\n  def after_find(by, what, driver)\n    display_growl(driver, "Found element #{what}")\n  end\n\n  def before_click(element, driver)\n    display_growl(driver, "Clicking on #{element.text}")\n    @pre_click_url = driver.current_url\n  end\n\n  def after_click(element, driver)\n    unless @pre_click_url == driver.current_url\n      add_growl(driver)\n      display_growl(driver, "URL changed to #{driver.current_url}")\n    end\n  end\n\n  private\n\n  def add_growl(driver)\n     driver.execute_script("if (!window.jQuery) {\n        var jquery = document.createElement(\'script\'); jquery.type = \'text/javascript\';\n        jquery.src = \'https://ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js\';\n        document.getElementsByTagName(\'head\')[0].appendChild(jquery);\n      }")\n\n    driver.execute_script("$.getScript(\'http://the-internet.herokuapp.com/js/vendor/jquery.growl.js\')")\n\n    driver.execute_script("$(\'head\').append(\'<link rel=\\"stylesheet\\" href=\\"http://the-internet.herokuapp.com/css/jquery.growl.css\\" type=\\"text/css\\" />\');")\n\n    sleep 1\n  end\n\n  def display_growl(driver, message)\n    driver.execute_script("$.growl({ title: \'Selenium\', message: \'#{message}\' });")\n    sleep 0.5\n  end\n\nend\n')),(0,a.kt)("p",null,"Our Event Listener helper methods give us access to the driver object at the precise moments we want in our test steps, and by wiring up growl notifications (see ",(0,a.kt)("inlineCode",{parentName:"p"},"add_growl")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"display_growl"),") we can now display notification messages in the browser window automatically without any additional work in our test code."),(0,a.kt)("p",null,"Let's go ahead and wire up our test code to use this new wrapper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: wrapper_test.rb\n\nrequire 'selenium-webdriver'\nrequire_relative 'wrapper'\nrequire 'rspec/expectations'\ninclude RSpec::Matchers\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox, listener: Wrapper.new\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n\nrun do\n  @driver.get 'http://the-internet.herokuapp.com'\n  @driver.find_elements(css: 'a').last.click\nend\n")),(0,a.kt)("p",null,"Everything here is pretty standard with the exception of two small changes to handle our wrapper. We first need to include the file (",(0,a.kt)("inlineCode",{parentName:"p"},"require_relative 'wrapper'"),") and then pass in an instance of the wrapper to Selenium (",(0,a.kt)("inlineCode",{parentName:"p"},"listener: Wrapper.new"),")."),(0,a.kt)("p",null,"Now if we run our test (",(0,a.kt)("inlineCode",{parentName:"p"},"ruby wrapper_test.rb"),") then we will see notification messages appear around each of the test actions as they occur."),(0,a.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Load the browser"),(0,a.kt)("li",{parentName:"ul"},"Load jQuery if it's not already loaded"),(0,a.kt)("li",{parentName:"ul"},"Load jQuery Growl and it's styles"),(0,a.kt)("li",{parentName:"ul"},"Display notifications in the browser window for each of the test actions")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"To see a video demo of this test, ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/98736887"},"click here"),"."),(0,a.kt)("p",null,"Happy Testing!"))}s.isMDXComponent=!0}}]);