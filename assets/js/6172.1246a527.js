"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[6172],{46172:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>u,frontMatter:()=>o,toc:()=>i});var r=n(87462),a=(n(67294),n(3905));const o={},s=void 0,i=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],l={toc:i},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"Before we get started we'll need to ",(0,a.kt)("a",{parentName:"p",href:"http://bmp.lightbody.net/"},"download a copy of BrowserMob Proxy"),". Once we have that, we'll want to include our requisite libraries:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"selenium-webdriver")," to control the browser"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"browsermob/proxy")," to configure/use BrowserMob Proxy"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"typhoeus")," to replay HTTP requests")),(0,a.kt)("p",null,"After that, we can create methods to configure the proxy server (",(0,a.kt)("inlineCode",{parentName:"p"},"configure_proxy"),"), set the browser profile to use the proxy server (",(0,a.kt)("inlineCode",{parentName:"p"},"browser_profile"),"), pull these together so the test will have a working browser that uses the proxy server (",(0,a.kt)("inlineCode",{parentName:"p"},"setup"),"), and tear things down after running the test (",(0,a.kt)("inlineCode",{parentName:"p"},"teardown"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: load.rb\n\nrequire 'selenium-webdriver'\nrequire 'browsermob/proxy'\nrequire 'typhoeus'\n\ndef configure_proxy\n  proxy_binary = BrowserMob::Proxy::Server.new('./browsermob-proxy/bin/browsermob-proxy')\n  proxy_binary.start\n  proxy_binary.create_proxy\nend\n\ndef browser_profile\n  browser_profile = Selenium::WebDriver::Firefox::Profile.new\n  browser_profile.proxy = @proxy.selenium_proxy\n  browser_profile\nend\n\ndef setup\n  @proxy = configure_proxy\n  @driver = Selenium::WebDriver.for :firefox, profile: browser_profile\nend\n\ndef teardown\n  @driver.quit\n  @proxy.close\nend\n")),(0,a.kt)("p",null,"Next we'll want to tell the proxy server to capture traffic and return a payload (a.k.a. a HTTP Archive, or HAR). For easier debugging later, we will want to add some error handling to output the results from each HTTP request that's replayed (",(0,a.kt)("inlineCode",{parentName:"p"},"error_handling"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},'def capture_traffic\n  @proxy.new_har\n  yield\n  @proxy.har\nend\n\ndef error_handling(request)\n  request.on_complete do |response|\n    if response.success?\n      puts "success"\n    elsif response.timed_out?\n      puts "got a time out"\n    elsif response.code == 0\n      # Could not get an http response, something\'s wrong.\n      puts response.return_message\n    else\n      # Received a non-successful http response.\n      puts "HTTP request failed: " + response.code.to_s\n    end\n  end\nend\n')),(0,a.kt)("p",null,"Now for the meat of the issue -- replaying the requests."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},'def replay(http_requests, number_of_replays, debug = false)\n  requests = []\n  http_requests.entries.each do |entry|\n    requests << Typhoeus::Request.new(\n      entry.request.url,\n      method: entry.request.method.downcase.to_sym)\n  end\n\n  start_time = Time.now\n  puts "Start time: #{start_time}"\n  threads = []\n  number_of_replays.times do\n    threads << Thread.new do\n      requests.each do |request|\n        error_handling request if debug\n        request.run\n      end\n    end\n  end\n  threads.each {|thread| thread.join }\n  finish_time = Time.now\n  puts "Finish time: #{finish_time}"\n  puts "#{number_of_replays} runs completed in #{finish_time - start_time} seconds"\nend\n')),(0,a.kt)("p",null,"We start by iterating through each of the entries in the HAR payload, creating a new request for Typhoeus to use -- storing them all in an array."),(0,a.kt)("p",null,"After printing the current time to the terminal, we create a new thread and execute all of the Typhoeus HTTP requests within it (outputting the error handling for each request if a debug parameter is passed in). This gets repeated based on the number of times specified when ",(0,a.kt)("inlineCode",{parentName:"p"},"replay")," is called."),(0,a.kt)("p",null,"After the threads run and terminate, we output the current time, and then list the total time run time along with the number of replays attempted."),(0,a.kt)("p",null,"We can now pull all of this together by implementing a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"def run\n  setup\n  http_requests = capture_traffic { yield }\n  teardown\n  replay(http_requests, 100)\nend\n")),(0,a.kt)("p",null,"If we wanted to see the debug output, we would pass in ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," as a third parameter like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"replay(http_requests, 100, true)\n")),(0,a.kt)("p",null,"Now that everything's wired up, we can drop our Selenium actions into a run block."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"run do\n  @driver.get 'http://the-internet.herokuapp.com/dynamic_loading/2'\n  @driver.find_element(css: '#start button').click\n  Selenium::WebDriver::Wait.new(timeout: 8).until do\n    @driver.find_element(css: '#finish')\n  end\nend\n")),(0,a.kt)("p",null,"If we run this script without debugging turned on, then we should see something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"Start time: 2014-04-30 14:22:33 -0400\nFinish time: 2014-04-30 14:23:10 -0400\n100 runs completed in 37.575052 seconds\n")),(0,a.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Load a browser"),(0,a.kt)("li",{parentName:"ul"},"Visit the page and complete the actions specified while capturing the HTTP requests"),(0,a.kt)("li",{parentName:"ul"},"Close the browser and shutdown the proxy server"),(0,a.kt)("li",{parentName:"ul"},"Replay the HTTP requests generated by Selenium 100 times in parallel")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Hopefully this was helpful in helping you figure out how to do load testing."),(0,a.kt)("p",null,"Happy Testing!"))}u.isMDXComponent=!0}}]);