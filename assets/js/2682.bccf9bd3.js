"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[2682],{92682:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>u,frontMatter:()=>s,toc:()=>i});var a=n(87462),r=(n(67294),n(3905));const s={},l=void 0,i=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],o={toc:i},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Let's assume we have a bunch of tests written in ",(0,r.kt)("a",{parentName:"p",href:"http://rspec.info/"},"RSpec"),", which would look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"\u2514\u2500\u2500 spec\n    \u251c\u2500\u2500 11_spec.rb\n    \u251c\u2500\u2500 1_spec.rb\n    \u251c\u2500\u2500 2_spec.rb\n    \u251c\u2500\u2500 3_spec.rb\n    \u251c\u2500\u2500 4_spec.rb\n    \u251c\u2500\u2500 5_spec.rb\n    \u251c\u2500\u2500 6_spec.rb\n    \u251c\u2500\u2500 7_spec.rb\n    \u251c\u2500\u2500 8_spec.rb\n    \u251c\u2500\u2500 9_spec.rb\n    \u2514\u2500\u2500 this_spec.rb\n")),(0,r.kt)("p",null,"And let's assume that we will execute these tests in parallel (using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/grosser/parallel_tests"},"parallel_tests"),")."),(0,r.kt)("p",null,"Some of the tests will pass, and some of them will fail. In order to track which ones fail, we will want to keep a\nlog. The simplest way to do this would be to output a list of failures to a file. That way the list of failures will\npersist after the suite of tests completes, so we can perform a retry action using the list of failures."),(0,r.kt)("p",null,"Thankfully RSpec comes with some of the plumbing to help accomplish this -- through the use of a\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dchelimsky/rspec/wiki/Custom-Formatters"},"custom formatter"),"; specifically the ",(0,r.kt)("a",{parentName:"p",href:"http://rubydoc.info/gems/rspec-core/2.6.4/RSpec/Core/Formatters/BaseFormatter"},"base formatter"),"."),(0,r.kt)("p",null,"Let's create one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'# filename: failure_catcher.rb\n\nrequire \'rspec/core/formatters/base_formatter\'\n\nclass FailureCatcher < RSpec::Core::Formatters::BaseFormatter\n\n  # create files called rspec_#.failures with a list of failed examples\n  def dump_failures\n    return if failed_examples.empty?\n    f = File.new("rspec#{ENV[\'TEST_ENV_NUMBER\']}.failures", "w+")\n    failed_examples.each do |example|\n      f.puts retry_command(example)\n    end\n    f.close\n  end\n\n  def retry_command(example)\n    example_name = example.full_description.gsub("\\"", "\\\\\\"")\n    "-e \\"#{example_name}\\""\n  end\n\nend\n')),(0,r.kt)("p",null,"In order to extend the base formatter we first need to require it, and then inherit from it when declaring our\nclass (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"< RSpec::Core::Formatters::BaseFormatter"),")."),(0,r.kt)("p",null,"After that we have access to the helper method we want (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"dump_failures"),"). In ",(0,r.kt)("inlineCode",{parentName:"p"},"dump_failures")," we can access\ndetailed information about each failed test through the ",(0,r.kt)("inlineCode",{parentName:"p"},"failed_examples")," accessor."),(0,r.kt)("p",null,"After checking to see if there are any failed examples, we create a new uniquely named file (leveraging the\nenvironment variable created by our parallel executor), iterate through all of the failed examples, and store a\nproperly formatted retry execution command with the name of the failed test."),(0,r.kt)("p",null,"To use this formatter we'll need to specify it at run-time, and to leverage a retry action we'll need to wrap our\nrun-time execution. Let's wire all of this up using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jimweirich/rake"},"Rake"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: Rakefile\n\ndef gather_failures\n  opts = \"\"\n  files = Dir.glob('*.failures')\n  files.each { |file| opts << File.read(file).gsub(/\\n/, ' ') }\n  all_failures = './all.failures'\n  File.write(all_failures, opts.rstrip)\n  return File.read all_failures\nend\n\ndef cleanup(files = '')\n  system(\"rm #{files}\") unless Dir.glob(\"#{files}\").empty?\nend\n\ndef launch(params = {})\n  if params[:test_options].include? '-e'\n    count = params[:test_options].split(/failed/).count - 1\n    puts \"Retrying #{count} failed tests!\"\n  end\n  system(\"parallel_rspec -n #{params[:processes] || 5} \\\n          --test-options '#{params[:test_options]}' spec\")\nend\n\ndef run(processes = 5)\n  launch(processes: processes,\n    test_options: '--require ./failure_catcher.rb \\\n    --format FailureCatcher')\nend\n\ndef rerun(processes = 5)\n  launch(processes: processes, test_options: gather_failures)\nend\n\ndesc \"parallel test execution with failure retries\"\ntask :run_tests, :number_of_processes do |t, args|\n  run args[:number_of_processes]\n  unless $?.success?\n    rerun args[:number_of_processes]\n    cleanup '*.failures'\n  end\nend\n")),(0,r.kt)("p",null,"There are five methods and one Rake task. The first two methods (",(0,r.kt)("inlineCode",{parentName:"p"},"gather_failures")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cleanup"),") are for rounding\nup a list of failed tests from the *.failure files and deleting them when we're finished. The next three methods\n(",(0,r.kt)("inlineCode",{parentName:"p"},"launch"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"run"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"rerun"),") are for executing the test suite and retrying just the failures."),(0,r.kt)("p",null,"The Rake task is where we tie everything together."),(0,r.kt)("p",null,"In it we make the number of concurrent processes configurable through the use of an optional run-time argument.\nWe then call ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," (passing in the argument) which executes the full suite. After the suite completes,\nwe perform a check against the exit code to see if there were any failures. If there were, then we call\n",(0,r.kt)("inlineCode",{parentName:"p"},"rerun")," (along with the argument for number of processes),  and then call ",(0,r.kt)("inlineCode",{parentName:"p"},"cleanup")," to remove the failure files."),(0,r.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Tests execute in parallel"),(0,r.kt)("li",{parentName:"ul"},"A list of failed tests get stored in output files (one for each process)"),(0,r.kt)("li",{parentName:"ul"},"Failed tests get rerun"),(0,r.kt)("li",{parentName:"ul"},"Output files for failed tests get deleted")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Hat-tip to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dblock/rspec-rerun"},"rspec-rerun")," for the initial implementation, and to ",(0,r.kt)("a",{parentName:"p",href:"http://artsy.github.io/blog/2012/05/15/how-to-organize-over-3000-rspec-specs-and-retry-test-failures/"},"the write-up that led me there"),"."),(0,r.kt)("p",null,"Happy Testing!"))}u.isMDXComponent=!0}}]);