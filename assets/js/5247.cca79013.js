"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[5247],{5247:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>i,default:()=>d,frontMatter:()=>r,toc:()=>l});var n=a(87462),s=(a(67294),a(3905));const r={},i=void 0,l=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],o={toc:l},p="wrapper";function d(e){let{components:t,...a}=e;return(0,s.kt)(p,(0,n.Z)({},o,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"example"},"Example"),(0,s.kt)("p",null,"To do this in RSpec, we're going to leverage ",(0,s.kt)("inlineCode",{parentName:"p"},"RSpec.configure")," in a file called ",(0,s.kt)("inlineCode",{parentName:"p"},"tag_lister.rb"),". To keep things simple, let's wrap this behavior in a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"list_tags")," and have it live within a module called ",(0,s.kt)("inlineCode",{parentName:"p"},"TagLister"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: tag_lister.rb\n\nrequire 'rspec'\n\nmodule TagLister\n  def self.list_tags\n    RSpec.configure do |c|\n      c.add_setting :tags\n      c.before(:suite) { RSpec.configuration.tags = {} }\n")),(0,s.kt)("p",null,"In our RSpec configuration we first need to create a place to store the tag data, so we add a setting called ",(0,s.kt)("inlineCode",{parentName:"p"},"tags")," and make it a hash."),(0,s.kt)("p",null,"Now we're ready to go through each test to find the tag data."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'# filename: tag_lister.rb\n\n...\n      c.around(:each) do |example|\n        tag_recorder = RSpec.configuration.tags\n        standard_keys = [:example_group,\n                         :block,\n                         :description_args,\n                         :caller,\n                         :execution_result,\n                         :full_description,\n                         :line_number,\n                         :file_path,\n                         :description,\n                         :described_class,\n                         :location]\n        example.metadata.each do |key, value|\n          this_tag = "#{key}:#{value}" unless standard_keys.include?(key)\n          unless this_tag.nil?\n            tag_recorder[this_tag] = [] unless tag_recorder[this_tag]\n            tag_recorder[this_tag] << [\n              example.metadata[:full_description],\n              example.metadata[:file_path],\n              example.metadata[:line_number]\n            ]\n          end\n        end\n      end\n\n')),(0,s.kt)("p",null,"In ",(0,s.kt)("inlineCode",{parentName:"p"},"around(:each)")," we're able to interogate each test (a.k.a. ",(0,s.kt)("inlineCode",{parentName:"p"},"example"),") to see if it contains any data in addition to the standard set of keys that we can expect from RSpec. If it does, then we assume that these additional keys are tags and store the test name, path to test file, and line number of the test file that uses this tag (or these tags)."),(0,s.kt)("p",null,"We store this information in an array (and potentially an array of arrays) within our ",(0,s.kt)("inlineCode",{parentName:"p"},"tags")," hash. Here's a sample data set to help wrap your head around it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'{"wip:true"=>[["One passes", "./spec/one_spec.rb", 2], ["One fails", "./spec/one_spec.rb", 3]],\n"smoke:true"=>[["Three passes", "./spec/three_spec.rb", 2], ["Three fails", "./spec/three_spec.rb", 3]],\n"story:BIZ-1234"=>[["Two passes", "./spec/two_spec.rb", 2]], "story:BIZ-1235"=>[["Two fails", "./spec/two_spec.rb", 3]]}\n')),(0,s.kt)("p",null,"Now that we have all of the tags and the test data that shows where they are in use, we can generate a simple report with it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'# filename: tag_lister.rb\n\n...\n      c.after(:suite) do\n        tags = RSpec.configuration.tags\n\n        case ENV[\'TAG_SORT_ORDER\']\n        when \'alphabetical\'\n          tags = tags.sort_by { |tag| tag[0] }\n        when \'usage\'\n          tags = tags.sort_by { |tag| tag[1].count }.reverse\n        end\n\n        puts "\\n\\n"\n        puts "***************"\n        puts "* TAGS IN USE *"\n        puts "***************"\n        puts "\\n"\n\n        tags.each do |tag|\n          puts "#{tag[0]} (used #{tag[1].count} times)"\n          tag[1].each do |test_data|\n            puts "  #{test_data[0]} (#{test_data[1]}:#{test_data[2]})\\n"\n          end\n        end\n\n        puts "\\n#{tags.count} tags in use: sorted in #{ENV[\'TAG_SORT_ORDER\']} order"\n\n      end\n    end\n\n')),(0,s.kt)("p",null,"There are a couple of different ways we'll likely want to see the tag data. So we wire up the ability to sort alphabetically by tag name as well as by usage in descending order (e.g., the number of times a tag is used). In our current tagging data structure, ",(0,s.kt)("inlineCode",{parentName:"p"},"tag[0]")," is the tag name (a.k.a. the hash key) and ",(0,s.kt)("inlineCode",{parentName:"p"},"tag[1]")," is the array that contains an array (or multiple arrays) of test data."),(0,s.kt)("p",null,"After sorting the tags, we output a heading (e.g., ",(0,s.kt)("inlineCode",{parentName:"p"},"* TAGS IN USE*"),"), iterate through the collection of tag & test data, and close things out with a summary statement (listing the total tag count and sorting method used)."),(0,s.kt)("p",null,"Now we just need to pull in our test files, start RSpec, and then add a trigger to run everything."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: tag_lister.rb\n\n...\n    tests = Dir.glob(File.join(Dir.getwd, 'spec/**/*'))\n    RSpec::Core::Runner.run(tests)\n\n  end\nend\n\nENV['TAG_SORT_ORDER'] = ARGV[0] || 'usage'\nTagLister.list_tags\n")),(0,s.kt)("p",null,"This script is built to live one level up from the test directory. And it assumes that the test directory is called ",(0,s.kt)("inlineCode",{parentName:"p"},"spec"),"."),(0,s.kt)("p",null,"We make it so we can pass an argument at runtime, which then gets fed into the tag sorting environment variable (",(0,s.kt)("inlineCode",{parentName:"p"},"ENV['TAG_SORT_ORDER']"),"). If no argument is provided, we default the value to ",(0,s.kt)("inlineCode",{parentName:"p"},"'usage'"),"."),(0,s.kt)("p",null,"When we save this and run it with ",(0,s.kt)("inlineCode",{parentName:"p"},"ruby tag_lister.rb"),", we should see a report outputted in the terminal."),(0,s.kt)("p",null,"Here is an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sh"},"......\n\n***************\n* TAGS IN USE *\n***************\n\nwip:true (used 2 times)\n  One passes (./spec/one_spec.rb:2)\n  One fails (./spec/one_spec.rb:3)\nsmoke:true (used 2 times)\n  Three passes (./spec/three_spec.rb:2)\n  Three fails (./spec/three_spec.rb:3)\nstory:BIZ-1234 (used 1 times)\n  Two passes (./spec/two_spec.rb:2)\nstory:BIZ-1235 (used 1 times)\n  Two fails (./spec/two_spec.rb:3)\n\n4 tags in use: sorted in usage order\n\n\nFinished in 0.00106 seconds (files took 0.09029 seconds to load)\n6 examples, 0 failures\n")),(0,s.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Iterate over each test, collecting tags and their test data"),(0,s.kt)("li",{parentName:"ul"},"Display a report in the terminal of tags in use (sorted based on run-time preference)")),(0,s.kt)("h2",{id:"summary"},"Summary"),(0,s.kt)("p",null,"If you'd like to see the code and example specs used to generate the above report, you can find them ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tourdedave/rspec-list-tags"},"here"),"."),(0,s.kt)("p",null,"Happy Testing!"))}d.isMDXComponent=!0}}]);