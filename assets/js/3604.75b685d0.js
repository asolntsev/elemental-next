"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[3604],{23604:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>d,frontMatter:()=>s,toc:()=>o});var a=n(87462),r=(n(67294),n(3905));const s={},i=void 0,o=[{value:"A brief primer on Good Test Writing",id:"a-brief-primer-on-good-test-writing",level:3},{value:"Atomic &amp; Autonomous Tests",id:"atomic--autonomous-tests",level:4},{value:"Grouping Tests",id:"grouping-tests",level:4},{value:"Being Descriptive",id:"being-descriptive",level:4},{value:"Test Runners",id:"test-runners",level:4},{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],l={toc:o},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"a-brief-primer-on-good-test-writing"},"A brief primer on Good Test Writing"),(0,r.kt)("p",null,"In order to write tests that work well in parallel there are some simple guidelines to follow:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Write atomic and autonomous tests"),(0,r.kt)("li",{parentName:"ul"},"Group like tests together in small batches"),(0,r.kt)("li",{parentName:"ul"},"Be descriptive"),(0,r.kt)("li",{parentName:"ul"},"Use a Test Runner")),(0,r.kt)("h4",{id:"atomic--autonomous-tests"},"Atomic & Autonomous Tests"),(0,r.kt)("p",null,"Each test needs to be concise (e.g. testing a single feature rather than multiple features) and be able to be run independently (e.g. sets up it's own data rather than relying on a previous test to do it). Doing this may require a mental shift, discipline, and more up front effort. But ",(0,r.kt)("strong",{parentName:"p"},"it will make a dramatic impact on the quality, effectiveness, and maintainability of your tests"),"."),(0,r.kt)("h4",{id:"grouping-tests"},"Grouping Tests"),(0,r.kt)("p",null,"As your test suite grows you should have multiple test files, each containing a small grouping of tests broken out by functionality that they're exercising. This will go a long way towards organization and maintenance as your test suite grows -- as well as faster execution times (depending on your approach to parallelization)."),(0,r.kt)("h4",{id:"being-descriptive"},"Being Descriptive"),(0,r.kt)("p",null,"Each test file should be named appropriately, and each test within it should have an informative name (even if it may be a bit verbose). Also, each test (or grouping of tests) should be tagged for flexible execution later (e.g. on a Continuous Integration server)."),(0,r.kt)("p",null,"This way you can run parts of your test suite as needed, and the results will be informative thanks to helpful naming."),(0,r.kt)("h4",{id:"test-runners"},"Test Runners"),(0,r.kt)("p",null,"At the heart of every testing framework is a test runner that does a lot of the heavy lifting (e.g. test group execution, easy global configuration for setup and teardown, reporting, etc.)."),(0,r.kt)("p",null,"So rather than reinvent the wheel, you can use one of the many that already exists (there's more than one for every language). And with it you can bolt on third party libraries to extend it's functionality if there's something missing -- like parallelization."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: For this example we will be using ",(0,r.kt)("a",{parentName:"strong",href:"http://rspec.info/"},"RSpec")," as the Test Runner and ",(0,r.kt)("a",{parentName:"strong",href:"https://github.com/grosser/parallel_tests"},"parallel-tests")," for parallelization.")),(0,r.kt)("p",null,"In RSpec, test files are referred to as 'specs'. So for our initial spec I've used the test code\nfrom ",(0,r.kt)("a",{parentName:"p",href:"https://elementalselenium.com/docs/how-to-work-with-tables/25-tables"},"a previous tip on working with Data Tables"),".\nDon't get too distracted by what the test steps are doing, the organization and naming of things is more important\nfor this example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# data_table_sorting_spec.rb\n\nrequire 'selenium-webdriver'\n\ndescribe 'Data Table Sorting' do\n\n  before(:each) do\n    @driver = Selenium::WebDriver.for :firefox\n  end\n\n  after(:each) do\n    @driver.quit\n  end\n\n  context 'Without Attributes' do\n\n    it 'in Ascending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_i }\n      (due_values == due_values.sort).should == true\n    end\n\n    it 'in Descending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_i }\n      (due_values == due_values.sort).should == false\n    end\n\n  end\n\n  context 'With Attributes' do\n\n    it 'in Ascending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table2 thead .dues').click\n      dues = @driver.find_elements(css: '#table2 tbody .dues')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_f }\n      (due_values == due_values.sort).should == true\n    end\n\n    it 'in Descending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table2 thead .dues').click\n      @driver.find_element(css: '#table2 thead .dues').click\n      dues = @driver.find_elements(css: '#table2 tbody .dues')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_f }\n      (due_values == due_values.sort).should == false\n    end\n\n  end\n\nend\n")),(0,r.kt)("p",null,"At the top of the file we include our dependent library (",(0,r.kt)("inlineCode",{parentName:"p"},"selenium-webdriver"),") and declare the name of our test group ('Sort Data Table') with a ",(0,r.kt)("inlineCode",{parentName:"p"},"describe")," statement. We then wire up our before and after actions which are responsible for setting up and tearing down an instance of Selenium for each test. Each of our tests are grouped into logical separations using ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," blocks and defined within an ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," block."),(0,r.kt)("p",null,"If we run this (e.g. with the command ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec data_table_sorting_spec.rb"),") it will fire up one browser at a time until each test is completed. And If we download, install, and run it through ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/grosser/parallel_tests"},"parallel_tests")," (e.g. with the command ",(0,r.kt)("inlineCode",{parentName:"p"},"paralell_rspec data_table_sorting_spec.rb"),") -- the same thing would happen. Why? Because parallel_tests executes things at the file level rather than at the individual test level (this holds true even when running tests by tag)."),(0,r.kt)("p",null,"In order to take advantage of parallelization we will need to break these tests up into different files."),(0,r.kt)("p",null,"But before we do that we can simplify our test code by abstracting out our setup and teardown actions into a central place (known as a ",(0,r.kt)("inlineCode",{parentName:"p"},"spec_helper")," in the RSpec parlance)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# spec_helper.rb\n\nrequire 'selenium-webdriver'\n\nRSpec.configure do |config|\n\n  config.before(:each) do\n    @driver = Selenium::WebDriver.for :firefox\n  end\n\n  config.after(:each) do\n    @driver.quit\n  end\n\nend\n")),(0,r.kt)("p",null,"Now that we have that we can create a new spec file and place some of our tests in it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# data_table_sorting_with_attributes_spec.rb\n\nrequire 'spec_helper'\n\ndescribe 'Sort Data Table' do\n\n  context 'With Attributes' do\n\n    it 'in Ascending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table2 thead .dues').click\n      dues = @driver.find_elements(css: '#table2 tbody .dues')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_f }\n      (due_values == due_values.sort).should == true\n    end\n\n    it 'in Descending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table2 thead .dues').click\n      @driver.find_element(css: '#table2 thead .dues').click\n      dues = @driver.find_elements(css: '#table2 tbody .dues')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_f }\n      (due_values == due_values.sort).should == false\n    end\n\n  end\n\nend\n")),(0,r.kt)("p",null,"Notice that the require statement has changed from ",(0,r.kt)("inlineCode",{parentName:"p"},"selenium-webdriver")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"spec_helper"),". Since we abstracted things\nout into a spec_helper file we now need to require it in all of our specs -- and the dependent libraries\nfor our test suite live there instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# data_table_sorting_without_attributes_spec.rb\n\nrequire 'spec_helper'\n\ndescribe 'Sort Data Table' do\n\n  context 'Without Attributes' do\n\n    it 'in Ascending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_i }\n      (due_values == due_values.sort).should == true\n    end\n\n    it 'in Descending Order' do\n      @driver.get 'http://the-internet.herokuapp.com/tables'\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click\n      dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')\n      due_values = []\n      dues.each { |due| due_values << due.text.gsub(/\\$/,'').to_i }\n      (due_values == due_values.sort).should == false\n    end\n\n  end\n\nend\n")),(0,r.kt)("p",null,"To get this last file we could have renamed the original test file, or created it anew and deleted the original."),(0,r.kt)("p",null,"Notice that the ",(0,r.kt)("inlineCode",{parentName:"p"},"describe")," name is the same between test files (e.g. 'Sort Data Table'). In RSpec names\ndo not need to be unique, and these tests logically fit together, this is a welcome consistency."),(0,r.kt)("p",null,"Now when we run our tests through parallel_tests we get concurrent test runs with two browsers firing at\nthe same time, yielding (in this case) roughly a 30% drop in execution times (e.g. 17 seconds down to 12 seconds).\nYou can easily up the number of processes being run as a command-line argument (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"-n 5"),"). But this will only\nmake a difference as you have more specs given how parallel_tests groups and executes things."),(0,r.kt)("p",null,"Now that we have a working example that runs concurrently, we can point it at a cloud offering like Sauce Labs,\nand have access to any browser we want. We just have to update our setup action in the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec_helper"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: This was covered in a previous tip. For a full write-up, go ",(0,r.kt)("a",{parentName:"strong",href:"https://elementalselenium.com/docs/cloud/26-cloud"},"here"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'# spec_helper.rb\n\nrequire \'selenium-webdriver\'\n\nRSpec.configure do |config|\n\n  config.before(:each) do\n    caps = Selenium::WebDriver::Remote::Capabilities.firefox\n    caps.browser_version = "115"\n    caps.platform_name = "Windows 11"\n    caps[:name] = self.example.metadata[:full_description]\n\n    @driver = Selenium::WebDriver.for(\n      :remote,\n      :url => "https://SAUCE_USERNAME:SAUCE_API_KEY@ondemand.saucelabs.com/wd/hub",\n      :capabilities => caps)\n  end\n\n  config.after(:each) do\n    @driver.quit\n  end\n\nend\n')),(0,r.kt)("p",null,"Now when we run our tests with parallel_tests we can see the concurrent execution happening in Sauce Labs."),(0,r.kt)("p",null,"Sauce Labs is built to handle your tests concurrently, so you should be able to turn the number of processes up with no sweat. You will just need to be cogniscent of how many parallel tests your account has access to (e.g. 3 for Sauce Open accounts)."),(0,r.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Several browsers open in parallel"),(0,r.kt)("li",{parentName:"ul"},"Each test runs in a different browser"),(0,r.kt)("li",{parentName:"ul"},"All browsers close"),(0,r.kt)("li",{parentName:"ul"},"If Sauce Labs was used, then the test results (along with a video recording, screenshots, and other debugging information) are available on the ",(0,r.kt)("a",{parentName:"li",href:"https://docs.saucelabs.com/test-results/viewing-test-results/"},"test results dashboard"),".")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Hopefully this tip has helped steer you on a path towards better test writing and parallelization."),(0,r.kt)("p",null,"Stay tuned for future tips where we'll cover how to take full advantage of your test suite by wiring it into a Continuous Integration server and making the requisite changes to your test runner."),(0,r.kt)("p",null,"Happy Testing!"))}d.isMDXComponent=!0}}]);