"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[10599],{10599:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>d,frontMatter:()=>i,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={},o=void 0,l=[{value:"Example",id:"example",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Summary",id:"summary",level:2}],p={toc:l},s="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"To start things off let's pull in our requisite libraries (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"selenium-webdriver")," to drive the browser, ",(0,a.kt)("inlineCode",{parentName:"p"},"rspec/expectations")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"RSpec::Matchers")," for our assertions, and ",(0,a.kt)("inlineCode",{parentName:"p"},"rest-client")," for our HTTP request) and wire up some simple ",(0,a.kt)("inlineCode",{parentName:"p"},"setup"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"teardown"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," methods."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"# filename: download_revisited.rb\n\nrequire 'selenium-webdriver'\nrequire 'rspec/expectations'\nrequire 'rest-client'\ninclude RSpec::Matchers\n\ndef setup\n  @driver = Selenium::WebDriver.for :firefox\nend\n\ndef teardown\n  @driver.quit\nend\n\ndef run\n  setup\n  yield\n  teardown\nend\n")),(0,a.kt)("p",null,"Now we're ready to write up our test."),(0,a.kt)("p",null,"It's just a simple matter of visiting the page with download links, grabbing a URL from one of them, and performing a ",(0,a.kt)("inlineCode",{parentName:"p"},"HEAD")," request with it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"run do\n  @driver.get 'http://the-internet.herokuapp.com/download'\n  link = @driver.find_element(css: '.example a').attribute('href')\n  response = RestClient.head link\n  expect(response.headers[:content_type]).to eql('application/octet-stream')\n  expect(response.headers[:content_length].to_i).to be > 0\nend\n")),(0,a.kt)("p",null,"Once we receive the response we can check it's header for the ",(0,a.kt)("inlineCode",{parentName:"p"},"content_type")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"content_length")," to make sure the file is the correct type and not empty."),(0,a.kt)("h2",{id:"expected-behavior"},"Expected Behavior"),(0,a.kt)("p",null,"If you save this and run it (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"ruby download_revisited.rb")," from the command-line) here is what will will happen:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Open the browser"),(0,a.kt)("li",{parentName:"ul"},"Load the page"),(0,a.kt)("li",{parentName:"ul"},"Grab the URL of the first download link"),(0,a.kt)("li",{parentName:"ul"},"Perform a ",(0,a.kt)("inlineCode",{parentName:"li"},"HEAD")," request against it with an HTTP library"),(0,a.kt)("li",{parentName:"ul"},"Store the response"),(0,a.kt)("li",{parentName:"ul"},"Check the response headers to see that the file type is correct"),(0,a.kt)("li",{parentName:"ul"},"Check the response headers to see that the file is not empty")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Compared to the browser specific configuration with Selenium this is hands-down a leaner, faster, and more maintainable approach."),(0,a.kt)("p",null,"Happy Testing!"))}d.isMDXComponent=!0}}]);